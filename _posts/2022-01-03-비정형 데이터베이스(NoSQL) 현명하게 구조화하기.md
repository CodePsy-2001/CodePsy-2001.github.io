---
title: "비정형 데이터베이스(NoSQL) 현명하게 구조화하기"
date: 2022-01-04 01:14:11 +0900
categories: [프로그래밍, 메모]
tags: [database, NoSQL, firebase, 게임]
---



# 비정형 데이터베이스(NoSQL)를 사용해야 할 경우

1. 유연한 스키마가 필요한 경우
   - 특정 key값에 대한 명확한 정의를 내릴 수 없을 때
   - 배열, JSON 객체, (알 수 없는 길이의) 바이트 데이터 등을 담아야 할 때

2. 데이터베이스 분산처리가 필요할 경우
3. 소규모의 복잡한 쿼리를 많이 요청할 때

이러한 키-값 형태의 비정형 데이터베이스는 기본적으로 JSON 형태와 유사하다. 비정형 데이터베이스를 현명하게 구조화하는 방법은 JSON 통신값을 주고받아야 하는 모든 분야에서 활용될 수 있다.



# 예제

사용자가 프로필과 연락처 목록을 저장할 수 있는 채팅 앱을 만든다고 하자. 연락처 저장을 NoSQL로 처리한다.

일반적인 형태는 다음과 같다...

```json
{
    "users": {
        "chulsu12": {
            "name": "김 철수",
            "contacts": { "minji23": true, },
        },
        "minji23": { ... },
        "hodong34": { ... }
    }
}
```

사용자 프로필을 /users/$uid 경로에서 접근하도록 만들었다.



## 깊이를 얕게 만들자

NoSQL은 특정 노드에 대한 읽기/쓰기 작업을 수행하려면 해당 노드에 속한 모든 데이터에 대한 권한을 함께 부여해야 한다. 데이터의 깊이가 깊어지면 DB서버의 연산량이 많아지고, 보안 위협도 초래할 수 있다.

다음 예제를 생각해 보라. 채팅 데이터베이스 구조를 잘못 만들면 이런 모양이 되기 쉽다.

```json
{
	"chats": {
        "c1": {
            "title": "열심히 공부하는 사람들",
            "messages": {
                "m1": { "sender": "chulsu12", "message": "앞으로 열심히 공부합시다!" },
                "m2": { ... }
                // 이 뒤로 m이 수백개가 있다면...?
            }
        },
        "c2": { ... }
    }
}
```

이렇게 만들면, "열심히 공부하는 사람들"이라는 채팅방 제목을 얻기 위해 c1 노드에 접근해야 하고, 해당 채팅방에 잠재적으로 있을지도 모르는 채팅 노드 수백만개에 대한 일괄 접근을 DB에 요청하게 된다.

비정형 데이터베이스를 올바르게 구조화하려면, 데이터의 비정규화를 통해 접근 경로를 분할해야 한다.

다음 예제를 생각해 보라. 비정형 데이터베이스가 잘 평면화되어 있다.

```json
{
    // chats 노드는 채팅방 자체에 대한 정보만 담는다.
    "chats": {
        "c1": {
            "title": "열심히 공부하는 사람들 채팅방",
            "lastMessage": 45,
        },
        "c2": { ... }
    },
    // members 노드는 채팅방의 참여자에 대한 정보만 담는다.
    "members": {
        "c1": {
            "chulsu12": true,
            "minji23": true,
            "hodong34": false // 차단된 사람
        },
        "c2": { ... }
    },
    // messages 노드는 채팅방의 메세지만 담는다.
    "messages": {
        "c1": {
            "m1": { "sender": "chulsu12", "message": "앞으로 열심히 공부합시다!" },
            "m2": { ... },
            "m3": { ... }
        },
        "c2": { ... }
    }       
}
```

이렇게 만들면 메타데이터를 불러오는 데에 쓸데없이 트래픽을 낭비하지 않아도 된다.

노드별로 책임을 명확히 분리한 덕분에, 데이터 구조에 추가적인 데이터를 담을 수 있는 유연성도 확보되었다.



## 중복을 활용하자

앞선 연락처 예제를 다시 생각해보자.

사용자 간 1:1 연락처가 아니라, 그룹-사용자 소속 관계에 대한 양방향 데이터를 구조화해야 한다면 어떨까? 한 사용자가 여러 그룹에 속할 수 있고, 한 그룹이 여러 사용자를 가질 수 있다.

이러한 연결고리를 한쪽에서만 만들면, 다른 쪽에서는 색인에 문제가 생긴다.

```json
{
    "users": {
        "chulsu12": {
            "name": "김 철수",
            "groups": { "studyhard": true, "funnygame": true },
        },
        "minji23": { ... },
        "hodong34": { ... }
    }
}
```

"funnygame" 채팅방에 속한 사용자들을 불러오려면, 수백만 개일지도 모르는 users 노드를 전부 탐색해야 한다.

이럴 땐, 데이터 중복을 현명하게 활용해, 데이터 탐색 문제를 줄이는 게 좋다.

```json
{
    "users": {
        "chulsu12": {
            "name": "김 철수",
            "groups": { "studyhard": true, "funnygame": true },
        },
        "minji23": { ... },
        "hodong34": { ... }
    },
    "groups": {
        "studyhard": {
            "name": "열심히 공부하는 사람들 채팅방",
            "members": { "chulsu12": true, "minji23": true, "hodong34": true },
        },
        "funnygame": { ... }
    },
}
```

이러한 양방향 구조를 유지하려면, 유저와 그룹 사이의 연결이 추가될 때마다, user 노드와 group 노드 모두 최신 데이터에 대한 업데이트가 이뤄져야 한다. 수백만 개의 양방향 데이터를 다루는 올바른 방법이다.

ID를 키로 나열하고 값을 true로 설정하는 방식을 사용하면, 해당 노드의 데이터를 불러올 필요도 없이, 해당 노드가 존재하는지만 확인할 수 있다. 데이터 색인은 데이터 쿼리나 탐색보다 훨씬 속도가 빠르고 효율적이다.
